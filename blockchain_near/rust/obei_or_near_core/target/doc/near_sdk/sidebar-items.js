initSidebarItems({"attr":[["callback","`callback` is a marker attribute it does not generate code by itself."],["callback_vec","`callback_args_vec` is a marker attribute it does not generate code by itself."],["ext_contract",""],["init","`init` is a marker attribute it does not generate code by itself."],["near_bindgen",""],["result_serializer","`result_serializer` is a marker attribute it does not generate code by itself."],["serializer","`serializer` is a marker attribute it does not generate code by itself."]],"derive":[["BorshStorageKey","`BorshStorageKey` generates implementation for `BorshIntoStorageKey` trait. It allows the type to be passed as a unique prefix for persistent collections. The type should also implement or derive `BorshSerialize` trait."],["PanicOnDefault","`PanicOnDefault` generates implementation for `Default` trait that panics with the following message `The contract is not initialized` when `default()` is called. This is a helpful macro in case the contract is required to be initialized with either `init` or `init(ignore_state)`."]],"enum":[["PromiseOrValue",""],["PromiseResult","When there is a callback attached to one or more contract calls the execution results of these calls are available to the contract invoked through the callback."],["ReturnData",""]],"macro":[["log",""],["metadata","`metadata` generates the metadata method and should be placed at the very end of the `lib.rs` file. TODO: Once Rust allows inner attributes and custom procedural macros for modules we should switch this to be `#![metadata]` attribute at the top of the contract file instead. https://github.com/rust-lang/rust/issues/54727"],["setup_alloc","Boilerplate for setting up allocator used in Wasm binary."],["testing_env",""]],"mod":[["collections","Collections that offer an alternative to standard containers from `std::collections::*` by utilizing the underlying blockchain trie storage more efficiently."],["env","Blockchain-specific methods available to the smart contract. This is a wrapper around a low-level `BlockchainInterface`. Unless you know what you are doing prefer using `env::*` whenever possible. In case of cross-contract calls prefer using even higher-level API available through `callback_args`, `callback_args_vec`, `ext_contract`, `Promise`, and `PromiseOrValue`."],["json_types","Helper types for JSON serialization."],["test_utils",""],["utils",""]],"struct":[["Metadata","Metadata of the contract."],["MethodMetadata","Metadata of a single method."],["MockedBlockchain","Mocked blockchain that can be used in the tests for the smart contracts. It implements `BlockchainInterface` by redirecting calls to `VMLogic`. It unwraps errors of `VMLogic` to cause panic during the unit tests similarly to how errors of `VMLogic` would cause the termination of guest program execution. Unit tests can even assert the expected error message."],["Promise","A structure representing a result of the scheduled execution on another contract."],["RuntimeFeesConfig",""],["VMConfig",""],["VMContext","Context for the contract execution."]],"trait":[["BlockchainInterface","A low-level interface of either real or mocked blockchain that contract interacts with."],["BorshIntoStorageKey","Converts a Borsh serializable object into a `Vec<u8>` that is used for a storage key."],["IntoStorageKey","Converts Self into a `Vec<u8>` that is used for a storage key."]],"type":[["AccountId","Account identifier. Provides access to userâ€™s state."],["Balance","Balance is type for storing amounts of tokens."],["BlockHeight","Height of the block."],["BlockHeightDelta","Block height delta that measures the difference between `BlockHeight`s."],["CryptoHash","Raw type for 32 bytes of the hash."],["Duration","Raw type for duration in nanoseconds"],["EpochHeight","Height of the epoch."],["GCCount",""],["Gas","Gas is a type for storing amount of gas."],["IteratorIndex",""],["MerkleHash","Hash used by a struct implementing the Merkle tree."],["Nonce","Nonce for transactions."],["NumBlocks","Number of blocks in current group."],["NumSeats","Number of seats of validators (block producer or hidden ones) in current group (settlement)."],["NumShards","Number of shards in current group."],["PromiseId",""],["PromiseIndex",""],["ProtocolVersion",""],["PublicKey",""],["ReceiptIndex",""],["ShardId","Shard index, from 0 to NUM_SHARDS - 1."],["StorageUsage","StorageUsage is used to count the amount of storage used by a contract."],["StorageUsageChange","StorageUsageChange is used to count the storage usage within a single contract call."],["Timestamp","Raw type for timestamp in nanoseconds"],["ValidatorId","Validator identifier in current group."],["ValidatorMask","Mask which validators participated in multi sign."]]});